import { Event } from '@/types';
import { eventsAdapter } from '@/services/events-adapter';
import { tribeEventsAdapter } from '@/services/tribe-events-adapter';

// Solo datos reales de WordPress API - sin fallbacks

// Cache para evitar m√∫ltiples llamadas a la API
let upcomingEventsCache: Event[] | null = null;
let pastEventsCache: Event[] | null = null;
let cacheTimestamp: number = 0;
const CACHE_DURATION = 60 * 60 * 1000; // 1 hour to reduce API calls

// Funci√≥n para verificar si el cache es v√°lido
function isCacheValid(): boolean {
  return Date.now() - cacheTimestamp < CACHE_DURATION;
}

// Funci√≥n para obtener eventos pr√≥ximos (Tribe API)
export async function getUpcomingEvents(): Promise<Event[]> {
  // Si tenemos cache v√°lido, retornarlo
  if (upcomingEventsCache && isCacheValid()) {
    return upcomingEventsCache;
  }

  try {
    // Limpiar cache para debugging
    upcomingEventsCache = null;
    
    const tribeEvents = await tribeEventsAdapter.getUpcomingEvents(12);
    
    upcomingEventsCache = tribeEvents;
    cacheTimestamp = Date.now();
    return tribeEvents;
  } catch (error) {
    console.error('‚ùå Error loading Tribe Events upcoming events:', error);
    upcomingEventsCache = [];
    cacheTimestamp = Date.now();
    return [];
  }
}

// Funci√≥n para obtener eventos pasados inicial (solo los primeros 12)
export async function getPastEvents(): Promise<Event[]> {
  // Si tenemos cache v√°lido, retornarlo
  if (pastEventsCache && isCacheValid()) {
    return pastEventsCache;
  }

  try {
    // Clear cache for debugging - but don't reset timestamp yet
    pastEventsCache = null;
    
    const tribeEvents = await tribeEventsAdapter.getPastEvents(12); // Reduced from 50 to 12
    
    // Ensure we have a valid array before caching
    if (Array.isArray(tribeEvents)) {
      pastEventsCache = tribeEvents;
      cacheTimestamp = Date.now();
      return tribeEvents;
    } else {
      console.warn('‚ö†Ô∏è getPastEvents: tribeEventsAdapter returned non-array:', typeof tribeEvents);
      pastEventsCache = [];
      cacheTimestamp = Date.now();
      return [];
    }
  } catch (error) {
    console.error('‚ùå Error loading Tribe Events past events:', error);
    pastEventsCache = [];
    cacheTimestamp = Date.now();
    return [];
  }
}

// Nueva funci√≥n para cargar m√°s eventos pasados
export async function getPastEventsPage(page: number, pageSize: number = 12): Promise<Event[]> {
  try {
    const offset = (page - 1) * pageSize;
    const tribeEvents = await tribeEventsAdapter.getPastEventsPage(offset, pageSize);
    
    if (Array.isArray(tribeEvents)) {
      return tribeEvents;
    } else {
      console.warn('‚ö†Ô∏è getPastEventsPage: tribeEventsAdapter returned non-array:', typeof tribeEvents);
      return [];
    }
  } catch (error) {
    console.error('‚ùå Error loading paginated past events:', error);
    return [];
  }
}

// Funci√≥n para buscar eventos
export async function searchEvents(query: string): Promise<Event[]> {
  try {
    console.log('üîç Searching events in WordPress:', query);
    const searchResults = await eventsAdapter.searchEvents(query, 20);
    
    if (searchResults.length > 0) {
      console.log('‚úÖ Search results found:', searchResults.length);
      return searchResults;
    } else {
      console.log('‚ö†Ô∏è No WordPress search results found');
      return [];
    }
  } catch (error) {
    console.error('‚ùå Error searching events:', error);
    return [];
  }
}

// Funci√≥n para limpiar cache (√∫til para desarrollo)
export function clearEventsCache(): void {
  upcomingEventsCache = null;
  pastEventsCache = null;
  cacheTimestamp = 0;
  console.log('üóëÔ∏è Events cache cleared');
}

// Todos los eventos vienen ahora exclusivamente de WordPress API